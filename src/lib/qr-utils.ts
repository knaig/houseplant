/**
 * QR Code utilities for token extraction, validation, and processing
 */

export type QRCodeType = 'PLANT_TOKEN' | 'URL' | 'OTHER'

export interface QRProcessingResult {
  type: QRCodeType
  token?: string
  isValid: boolean
  error?: string
}

/**
 * Error messages for QR code processing
 */
export const QR_ERROR_MESSAGES = {
  INVALID_FORMAT: 'Invalid QR code format. Please scan a valid plant token QR code.',
  INVALID_TOKEN: 'Invalid token format. Token must be alphanumeric.',
  EXPIRED_TOKEN: 'This token has expired or is no longer valid.',
  NO_TOKEN_FOUND: 'No valid token found in QR code.',
  INVALID_URL: 'Invalid claim URL format.',
  UNSUPPORTED_QR: 'This QR code is not supported. Please scan a plant token QR code.',
} as const

/**
 * Extract token from QR code data
 * Handles full URLs, relative URLs, and raw tokens
 */
export function extractTokenFromQR(qrData: string): string | null {
  if (!qrData || typeof qrData !== 'string') {
    return null
  }

  // Clean the input
  const cleanData = qrData.trim()

  // Check if it's a raw token (alphanumeric only)
  if (isValidTokenFormat(cleanData)) {
    return cleanData
  }

  // Try to parse as URL
  try {
    let url: URL
    
    // Handle relative URLs
    if (cleanData.startsWith('/claim')) {
      url = new URL(cleanData, 'https://example.com')
    } else {
      url = new URL(cleanData)
    }

    // Extract token from query parameters
    const token = url.searchParams.get('token')
    if (token && isValidTokenFormat(token)) {
      return token
    }
  } catch {
    // Not a valid URL, continue with other checks
  }

  return null
}

/**
 * Validate QR token format
 * Tokens are alphanumeric strings generated by createClaimToken()
 */
export function validateQRToken(token: string): boolean {
  return isValidTokenFormat(token)
}

/**
 * Check if a string matches the expected token format
 * Based on createClaimToken() pattern: alphanumeric, ~26 characters
 */
function isValidTokenFormat(token: string): boolean {
  if (!token || typeof token !== 'string') {
    return false
  }

  // Token should be alphanumeric and reasonable length
  // Based on createClaimToken(): 2 random strings of ~13 chars each
  const tokenRegex = /^[a-zA-Z0-9]{20,30}$/
  return tokenRegex.test(token)
}

/**
 * Detect the type of QR code data
 */
export function getQRCodeType(qrData: string): QRCodeType {
  if (!qrData || typeof qrData !== 'string') {
    return 'OTHER'
  }

  const cleanData = qrData.trim()

  // Check if it's a raw plant token
  if (isValidTokenFormat(cleanData)) {
    return 'PLANT_TOKEN'
  }

  // Check if it's a claim URL
  if (isValidClaimURL(cleanData)) {
    return 'URL'
  }

  return 'OTHER'
}

/**
 * Validate if a URL is a valid plant claim URL
 */
export function isValidClaimURL(url: string): boolean {
  try {
    let parsedUrl: URL
    
    if (url.startsWith('/claim')) {
      parsedUrl = new URL(url, 'https://example.com')
    } else {
      parsedUrl = new URL(url)
    }

    // Check if it's a claim URL with a token parameter
    return parsedUrl.pathname === '/claim' && 
           parsedUrl.searchParams.has('token') &&
           isValidTokenFormat(parsedUrl.searchParams.get('token') || '')
  } catch {
    return false
  }
}

/**
 * Process QR code data and return structured result
 */
export function processQRCode(qrData: string): QRProcessingResult {
  const type = getQRCodeType(qrData)
  
  if (type === 'OTHER') {
    return {
      type,
      isValid: false,
      error: QR_ERROR_MESSAGES.UNSUPPORTED_QR
    }
  }

  const token = extractTokenFromQR(qrData)
  
  if (!token) {
    return {
      type,
      isValid: false,
      error: QR_ERROR_MESSAGES.NO_TOKEN_FOUND
    }
  }

  if (!validateQRToken(token)) {
    return {
      type,
      isValid: false,
      error: QR_ERROR_MESSAGES.INVALID_TOKEN
    }
  }

  return {
    type,
    token,
    isValid: true
  }
}

/**
 * Format token for display in UI
 * Shows first 8 and last 4 characters with ellipsis
 */
export function formatTokenForDisplay(token: string): string {
  if (!token || token.length <= 12) {
    return token
  }
  
  return `${token.substring(0, 8)}...${token.substring(token.length - 4)}`
}

/**
 * Sanitize user input for QR token entry
 * Remove whitespace but preserve case for case-sensitive tokens
 */
export function sanitizeQRInput(input: string): string {
  return input.trim()
}

/**
 * Check if the current environment supports camera-based QR scanning
 */
export function supportsQRScanning(): boolean {
  if (typeof window === 'undefined') {
    return false
  }

  // Check for camera support
  const hasGetUserMedia = !!(
    navigator.mediaDevices && 
    navigator.mediaDevices.getUserMedia
  )

  return hasGetUserMedia
}
